<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é•¿æ–¹å½¢ä¸­ä»»æ„è§’åº¦æœ€å¤§åŠåœ† - å®Œæ•´ç‰ˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .calculation-box {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        .calculation-box h2 {
            margin-top: 0;
            font-size: 1.8em;
        }
        .formula {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            backdrop-filter: blur(5px);
        }
        .result {
            font-size: 1.4em;
            font-weight: bold;
            text-align: center;
            background: rgba(255, 255, 255, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }
        .stats-box {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        .stat-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
        }
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(102, 126, 234, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        .control-group:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        .control-group label {
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        .control-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            width: 100px;
            text-align: center;
            transition: all 0.3s;
        }
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        .slider-container {
            width: 100%;
            margin: 10px 0;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: all 0.3s;
        }
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .button-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        .button-success {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            position: relative;
        }
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            background: white;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            cursor: crosshair;
        }
        .canvas-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 200px;
        }
        .optimization-info {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .optimization-info h3 {
            color: #81c784;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .progress-container {
            background: #4a5568;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #2d3748;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .highlight {
            background: rgba(129, 199, 132, 0.2);
            padding: 2px 4px;
            border-radius: 3px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .data-table th, .data-table td {
            border: 1px solid #4a5568;
            padding: 8px;
            text-align: center;
        }
        .data-table th {
            background: #4a5568;
            color: #e2e8f0;
        }
        .data-table tr:nth-child(even) {
            background: #3a4556;
        }
        .comparison-section {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            color: #2d3436;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .comparison-item {
            background: rgba(255, 255, 255, 0.3);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #e17055;
        }
        .export-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #dee2e6;
        }
        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .controls {
                grid-template-columns: 1fr;
            }
            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”„ é•¿æ–¹å½¢ä¸­ä»»æ„è§’åº¦æœ€å¤§åŠåœ† - å®Œæ•´ç‰ˆ</h1>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="calculation-box">
                    <h2>ğŸ“ å½“å‰æœ€ä¼˜è§£</h2>
                    <div class="formula">
                        <strong>é•¿æ–¹å½¢å°ºå¯¸:</strong> é•¿ = <span id="length-display">8</span>, å®½ = <span id="width-display">6</span>
                    </div>
                    <div class="formula">
                        <strong>æœ€å¤§åŠåœ†å‚æ•°:</strong><br>
                        â€¢ åŠå¾„: <span id="optimal-radius">0</span><br>
                        â€¢ è§’åº¦: <span id="optimal-angle">0</span>Â°<br>
                        â€¢ åœ†å¿ƒ: (<span id="optimal-x">0</span>, <span id="optimal-y">0</span>)<br>
                        â€¢ é¢ç§¯: <span id="optimal-area">0</span>
                    </div>
                    <div class="formula">
                        <strong>å‘¨é•¿è®¡ç®—:</strong> Ï€r + 2r = <span id="perimeter-formula">0</span>
                    </div>
                    <div class="result">
                        æœ€å¤§åŠåœ†å‘¨é•¿ = <span id="perimeter-result">0</span>
                    </div>
                </div>

                <div class="stats-box">
                    <h3>ğŸ“Š ç»Ÿè®¡ä¿¡æ¯</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="efficiency-ratio">0%</div>
                            <div class="stat-label">ç©ºé—´åˆ©ç”¨ç‡</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="compute-time">0ms</div>
                            <div class="stat-label">è®¡ç®—æ—¶é—´</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="tested-angles">0</div>
                            <div class="stat-label">æµ‹è¯•è§’åº¦æ•°</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="improvement">0%</div>
                            <div class="stat-label">vs æ ‡å‡†è§£</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="comparison-section">
                    <h3>ğŸ” æ–¹æ¡ˆå¯¹æ¯”</h3>
                    <div class="comparison-grid">
                        <div class="comparison-item">
                            <h4>æ°´å¹³æ”¾ç½® (0Â°)</h4>
                            <div>åŠå¾„: <span id="horizontal-radius">0</span></div>
                            <div>å‘¨é•¿: <span id="horizontal-perimeter">0</span></div>
                        </div>
                        <div class="comparison-item">
                            <h4>å‚ç›´æ”¾ç½® (90Â°)</h4>
                            <div>åŠå¾„: <span id="vertical-radius">0</span></div>
                            <div>å‘¨é•¿: <span id="vertical-perimeter">0</span></div>
                        </div>
                        <div class="comparison-item">
                            <h4>æœ€ä¼˜è§’åº¦</h4>
                            <div>åŠå¾„: <span id="optimal-radius-comp">0</span></div>
                            <div>å‘¨é•¿: <span id="optimal-perimeter-comp">0</span></div>
                        </div>
                        <div class="comparison-item">
                            <h4>æ”¹è¿›å¹…åº¦</h4>
                            <div>åŠå¾„: +<span id="radius-improvement">0</span>%</div>
                            <div>å‘¨é•¿: +<span id="perimeter-improvement">0</span>%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="length">é•¿æ–¹å½¢é•¿åº¦:</label>
                <input type="number" id="length" value="8" min="1" max="50" step="0.1">
            </div>
            <div class="control-group">
                <label for="width">é•¿æ–¹å½¢å®½åº¦:</label>
                <input type="number" id="width" value="6" min="1" max="50" step="0.1">
            </div>
            <div class="control-group">
                <label for="angle">
                    <span class="tooltip">åŠåœ†è§’åº¦ (æ‰‹åŠ¨è°ƒæ•´):
                        <span class="tooltiptext">0Â°=æ°´å¹³ï¼Œ90Â°=å‚ç›´ï¼Œå…¶ä»–è§’åº¦ä¸ºå€¾æ–œ</span>
                    </span>
                </label>
                <input type="number" id="angle" value="0" min="0" max="180" step="1">
                <div class="slider-container">
                    <input type="range" id="angle-slider" class="slider" min="0" max="180" value="0">
                </div>
            </div>
            <div class="control-group">
                <label for="precision">
                    <span class="tooltip">ä¼˜åŒ–ç²¾åº¦:
                        <span class="tooltiptext">æ•°å€¼è¶Šå°ç²¾åº¦è¶Šé«˜ï¼Œä½†è®¡ç®—æ—¶é—´æ›´é•¿</span>
                    </span>
                </label>
                <input type="number" id="precision" value="1" min="0.1" max="10" step="0.1">
            </div>
            <div class="control-group">
                <label for="center-step">ä¸­å¿ƒæœç´¢æ­¥é•¿:</label>
                <input type="number" id="center-step" value="0.1" min="0.01" max="1" step="0.01">
            </div>
            <div class="control-group">
                <label for="radius-precision">åŠå¾„ç²¾åº¦:</label>
                <input type="number" id="radius-precision" value="0.001" min="0.0001" max="0.1" step="0.0001">
            </div>
        </div>

        <div class="button-group">
            <button onclick="findOptimalSemicircle()" id="optimize-btn">
                <span id="optimize-text">ğŸ” å¯»æ‰¾æœ€ä¼˜è§£</span>
            </button>
            <button onclick="animateOptimization()" id="animate-btn">ğŸ¬ åŠ¨ç”»æ¼”ç¤º</button>
            <button onclick="stopAnimation()" class="button-danger" id="stop-btn">â¹ï¸ åœæ­¢</button>
            <button onclick="updateVisualization()" class="button-success">ğŸ”„ æ›´æ–°æ˜¾ç¤º</button>
            <button onclick="resetToDefault()">ğŸ”„ é‡ç½®é»˜è®¤</button>
            <button onclick="generateReport()">ğŸ“Š ç”ŸæˆæŠ¥å‘Š</button>
            <button onclick="exportData()">ğŸ’¾ å¯¼å‡ºæ•°æ®</button>
        </div>

        <div class="optimization-info">
            <h3>ğŸ¯ ä¼˜åŒ–è¿›åº¦</h3>
            <div class="progress-container">
                <div>å½“å‰æµ‹è¯•è§’åº¦: <span id="current-angle">0</span>Â°</div>
                <div>å½“å‰æœ€å¤§åŠå¾„: <span id="current-radius">0</span></div>
                <div>å‰©ä½™æ—¶é—´: <span id="remaining-time">--</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%">0%</div>
                </div>
                <div>å·²æµ‹è¯•: <span id="tested-count">0</span> / <span id="total-count">0</span> ä¸ªè§’åº¦</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
            <div class="canvas-overlay" id="canvas-info">
                <div><strong>å›¾ä¾‹:</strong></div>
                <div>ğŸŸ¢ æœ€ä¼˜è§£</div>
                <div>ğŸ”´ å½“å‰æ‰‹åŠ¨</div>
                <div>ğŸ“ å°ºå¯¸æ ‡æ³¨</div>
                <div>ğŸ¯ ç‚¹å‡»ç”»å¸ƒæŸ¥çœ‹åæ ‡</div>
            </div>
        </div>

        <div class="export-section">
            <h3>ğŸ“¤ æ•°æ®å¯¼å‡º</h3>
            <p>å¯¼å‡ºè®¡ç®—ç»“æœå’Œè¯¦ç»†æ•°æ®</p>
            <div class="export-buttons">
                <button onclick="exportToCSV()">ğŸ“Š CSVæ ¼å¼</button>
                <button onclick="exportToJSON()">ğŸ“‹ JSONæ ¼å¼</button>
                <button onclick="exportImage()">ğŸ–¼ï¸ å›¾ç‰‡æ ¼å¼</button>
                <button onclick="printResults()">ğŸ–¨ï¸ æ‰“å°ç»“æœ</button>
            </div>
        </div>

        <div class="optimization-info">
            <h3>ğŸ’» è¯¦ç»†åˆ†æç»“æœ</h3>
            <div id="analysis-details">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>è§’åº¦ (Â°)</th>
                            <th>åŠå¾„</th>
                            <th>å‘¨é•¿</th>
                            <th>é¢ç§¯</th>
                            <th>ä¸­å¿ƒX</th>
                            <th>ä¸­å¿ƒY</th>
                        </tr>
                    </thead>
                    <tbody id="results-table-body">
                    </tbody>
                </table>
            </div>
        </div>

        <div class="optimization-info">
            <h3>ğŸ”¬ ç®—æ³•è¯¦è§£</h3>
            <pre><code><span class="highlight">å®Œæ•´ç®—æ³•æµç¨‹ï¼š</span>

1. <span class="highlight">åˆå§‹åŒ–å‚æ•°</span>
   - é•¿æ–¹å½¢å°ºå¯¸: L Ã— W
   - è§’åº¦èŒƒå›´: [0Â°, 180Â°]
   - æœç´¢ç²¾åº¦: Î”Î¸

2. <span class="highlight">è§’åº¦éå†</span>
   for Î¸ in [0Â°, 180Â°] step Î”Î¸:
       max_radius = 0
       best_center = (0, 0)
       
3. <span class="highlight">ä¸­å¿ƒä½ç½®ä¼˜åŒ–</span>
   for cx in [0, L] step Î”x:
       for cy in [0, W] step Î”y:
           r = binary_search_max_radius(cx, cy, Î¸)
           if r > max_radius:
               max_radius = r
               best_center = (cx, cy)

4. <span class="highlight">çº¦æŸéªŒè¯</span>
   æ£€æŸ¥åŠåœ†æ‰€æœ‰ç‚¹æ˜¯å¦æ»¡è¶³:
   - 0 â‰¤ x â‰¤ L
   - 0 â‰¤ y â‰¤ W
   
5. <span class="highlight">å…¨å±€æœ€ä¼˜</span>
   è¿”å›ä½¿å‘¨é•¿ Ï€*r + 2*r æœ€å¤§çš„è§£

<span class="highlight">æ—¶é—´å¤æ‚åº¦ï¼š</span> O(n_Î¸ Ã— n_x Ã— n_y Ã— log(r_max))
<span class="highlight">ç©ºé—´å¤æ‚åº¦ï¼š</span> O(1)
</code></pre>
        </div>
    </div>

    <script>
        let isAnimating = false;
        let currentOptimal = { radius: 0, angle: 0, centerX: 0, centerY: 0 };
        let calculationHistory = [];
        let startTime = 0;

        // é«˜ç²¾åº¦æ•°å­¦è®¡ç®—
        function checkSemicircleInRectangle(centerX, centerY, radius, angle, length, width) {
            const angleRad = angle * Math.PI / 180;
            const numPoints = 100; // å¢åŠ æ£€æŸ¥ç‚¹æ•°é‡
            
            // æ£€æŸ¥åŠåœ†å¼§ä¸Šçš„ç‚¹
            for (let i = 0; i <= numPoints; i++) {
                const t = i * Math.PI / numPoints;
                
                // åŠåœ†ä¸Šçš„ç‚¹ï¼ˆæœªæ—‹è½¬ï¼‰
                let x = radius * Math.cos(t);
                let y = radius * Math.sin(t);
                
                // åº”ç”¨æ—‹è½¬
                const rotatedX = x * Math.cos(angleRad) - y * Math.sin(angleRad);
                const rotatedY = x * Math.sin(angleRad) + y * Math.cos(angleRad);
                
                // å¹³ç§»åˆ°ä¸­å¿ƒä½ç½®
                const finalX = centerX + rotatedX;
                const finalY = centerY + rotatedY;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨é•¿æ–¹å½¢å†…
                if (finalX < 0 || finalX > length || finalY < 0 || finalY > width) {
                    return false;
                }
            }
            
            // æ£€æŸ¥ç›´å¾„ç«¯ç‚¹
            const diameterEndX1 = centerX + radius * Math.cos(angleRad);
            const diameterEndY1 = centerY + radius * Math.sin(angleRad);
            const diameterEndX2 = centerX - radius * Math.cos(angleRad);
            const diameterEndY2 = centerY - radius * Math.sin(angleRad);
            
            return (diameterEndX1 >= 0 && diameterEndX1 <= length && 
                    diameterEndY1 >= 0 && diameterEndY1 <= width &&
                    diameterEndX2 >= 0 && diameterEndX2 <= length && 
                    diameterEndY2 >= 0 && diameterEndY2 <= width);
        }

        function findMaxRadiusForAngle(angle, length, width) {
            const centerStep = parseFloat(document.getElementById('center-step').value);
            const radiusPrecision = parseFloat(document.getElementById('radius-precision').value);
            
            let maxRadius = 0;
            let bestCenter = { x: 0, y: 0 };
            
            // éå†å¯èƒ½çš„ä¸­å¿ƒä½ç½®
            for (let cx = 0; cx <= length; cx += centerStep) {
                for (let cy = 0; cy <= width; cy += centerStep) {
                    // äºŒåˆ†æŸ¥æ‰¾æœ€å¤§åŠå¾„
                    let left = 0;
                    let right = Math.min(length, width);
                    
                    while (right - left > radiusPrecision) {
                        const mid = (left + right) / 2;
                        if (checkSemicircleInRectangle(cx, cy, mid, angle, length, width)) {
                            left = mid;
                        } else {
                            right = mid;
                        }
                    }
                    
                    if (left > maxRadius) {
                        maxRadius = left;
                        bestCenter = { x: cx, y: cy };
                    }
                }
            }
            
            return { radius: maxRadius, center: bestCenter };
        }

        async function findOptimalSemicircle() {
            const optimizeBtn = document.getElementById('optimize-btn');
            const optimizeText = document.getElementById('optimize-text');
            
            optimizeBtn.disabled = true;
            optimizeText.innerHTML = '<div class="loading-spinner"></div>è®¡ç®—ä¸­...';
            
            startTime = Date.now();
            
            const length = parseFloat(document.getElementById('length').value);
            const width = parseFloat(document.getElementById('width').value);
            const precision = parseFloat(document.getElementById('precision').value);
            
            let bestRadius = 0;
            let bestAngle = 0;
            let bestCenter = { x: 0, y: 0 };
            
            const totalAngles = Math.floor(180 / precision) + 1;
            document.getElementById('total-count').textContent = totalAngles;
            
            let testedCount = 0;
            calculationHistory = [];
            
            const results = [];
            
            for (let angle = 0; angle <= 180; angle += precision) {
                if (!optimizeBtn.disabled) break; // å¦‚æœè¢«åœæ­¢
                
                document.getElementById('current-angle').textContent = angle.toFixed(1);
                
                const result = findMaxRadiusForAngle(angle, length, width);
                
                // ä¿å­˜ç»“æœ
                results.push({
                    angle: angle,
                    radius: result.radius,
                    centerX: result.center.x,
                    centerY: result.center.y,
                    perimeter: result.radius * (Math.PI + 2),
                    area: result.radius * result.radius * Math.PI / 2
                });
                
                document.getElementById('current-radius').textContent = result.radius.toFixed(4);
                
                if (result.radius > bestRadius) {
                    bestRadius = result.radius;
                    bestAngle = angle;
                    bestCenter = result.center;
                }
                
                testedCount++;
                const progress = testedCount / totalAngles * 100;
                document.getElementById('tested-count').textContent = testedCount;
                document.getElementById('progress-fill').style.width = progress + '%';
                document.getElementById('progress-fill').textContent = progress.toFixed(1) + '%';
                
                // ä¼°ç®—å‰©ä½™æ—¶é—´
                const elapsed = Date.now() - startTime;
                const remaining = (elapsed / testedCount) * (totalAngles - testedCount);
                document.getElementById('remaining-time').textContent = 
                    remaining > 1000 ? (remaining / 1000).toFixed(1) + 's' : remaining.toFixed(0) + 'ms';
                
                // è®©æµè§ˆå™¨æœ‰æ—¶é—´æ›´æ–°UI
                if (testedCount % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // æ›´æ–°æœ€ä¼˜è§£
            currentOptimal = {
                radius: bestRadius,
                angle: bestAngle,
                centerX: bestCenter.x,
                centerY: bestCenter.y
            };
            
            calculationHistory = results;
            
            const computeTime = Date.now() - startTime;
            document.getElementById('compute-time').textContent = computeTime + 'ms';
            
            // æ›´æ–°æ˜¾ç¤º
            updateOptimalDisplay();
            updateComparisonDisplay();
            updateVisualization();
            updateResultsTable();
            
            optimizeBtn.disabled = false;
            optimizeText.innerHTML = 'ğŸ” å¯»æ‰¾æœ€ä¼˜è§£';
        }

        function updateOptimalDisplay() {
            const length = parseFloat(document.getElementById('length').value);
            const width = parseFloat(document.getElementById('width').value);
            
            document.getElementById('length-display').textContent = length;
            document.getElementById('width-display').textContent = width;
            document.getElementById('optimal-radius').textContent = currentOptimal.radius.toFixed(4);
            document.getElementById('optimal-angle').textContent = currentOptimal.angle.toFixed(1);
            document.getElementById('optimal-x').textContent = currentOptimal.centerX.toFixed(2);
            document.getElementById('optimal-y').textContent = currentOptimal.centerY.toFixed(2);
            
            const area = currentOptimal.radius * currentOptimal.radius * Math.PI / 2;
            document.getElementById('optimal-area').textContent = area.toFixed(4);
            
            const perimeter = currentOptimal.radius * (Math.PI + 2);
            document.getElementById('perimeter-formula').textContent = 
                `Ï€ Ã— ${currentOptimal.radius.toFixed(4)} + 2 Ã— ${currentOptimal.radius.toFixed(4)} = ${perimeter.toFixed(4)}`;
            document.getElementById('perimeter-result').textContent = perimeter.toFixed(4);
            
            // è®¡ç®—ç©ºé—´åˆ©ç”¨ç‡
            const rectangleArea = length * width;
            const efficiency = (area / rectangleArea * 100);
            document.getElementById('efficiency-ratio').textContent = efficiency.toFixed(1) + '%';
            
            document.getElementById('tested-angles').textContent = calculationHistory.length;
        }

        function updateComparisonDisplay() {
            const length = parseFloat(document.getElementById('length').value);
            const width = parseFloat(document.getElementById('width').value);
            
            // æ°´å¹³æ”¾ç½® (0Â°)
            const horizontalResult = findMaxRadiusForAngle(0, length, width);
            const horizontalPerimeter = horizontalResult.radius * (Math.PI + 2);
            document.getElementById('horizontal-radius').textContent = horizontalResult.radius.toFixed(4);
            document.getElementById('horizontal-perimeter').textContent = horizontalPerimeter.toFixed(4);
            
            // å‚ç›´æ”¾ç½® (90Â°)
            const verticalResult = findMaxRadiusForAngle(90, length, width);
            const verticalPerimeter = verticalResult.radius * (Math.PI + 2);
            document.getElementById('vertical-radius').textContent = verticalResult.radius.toFixed(4);
            document.getElementById('vertical-perimeter').textContent = verticalPerimeter.toFixed(4);
            
            // æœ€ä¼˜è§’åº¦
            const optimalPerimeter = currentOptimal.radius * (Math.PI + 2);
            document.getElementById('optimal-radius-comp').textContent = currentOptimal.radius.toFixed(4);
            document.getElementById('optimal-perimeter-comp').textContent = optimalPerimeter.toFixed(4);
            
            // æ”¹è¿›å¹…åº¦
            const bestStandard = Math.max(horizontalResult.radius, verticalResult.radius);
            const bestStandardPerimeter = Math.max(horizontalPerimeter, verticalPerimeter);
            
            const radiusImprovement = ((currentOptimal.radius - bestStandard) / bestStandard * 100);
            const perimeterImprovement = ((optimalPerimeter - bestStandardPerimeter) / bestStandardPerimeter * 100);
            
            document.getElementById('radius-improvement').textContent = Math.max(0, radiusImprovement).toFixed(2);
            document.getElementById('perimeter-improvement').textContent = Math.max(0, perimeterImprovement).toFixed(2);
            document.getElementById('improvement').textContent = Math.max(0, perimeterImprovement).toFixed(1) + '%';
        }

        function updateResultsTable() {
            const tbody = document.getElementById('results-table-body');
            tbody.innerHTML = '';
            
            // æ˜¾ç¤ºå‰10ä¸ªæœ€ä½³ç»“æœ
            const sortedResults = [...calculationHistory].sort((a, b) => b.radius - a.radius).slice(0, 10);
            
            sortedResults.forEach(result => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = result.angle.toFixed(1);
                row.insertCell(1).textContent = result.radius.toFixed(4);
                row.insertCell(2).textContent = result.perimeter.toFixed(4);
                row.insertCell(3).textContent = result.area.toFixed(4);
                row.insertCell(4).textContent = result.centerX.toFixed(2);
                row.insertCell(5).textContent = result.centerY.toFixed(2);
                
                if (result.angle === currentOptimal.angle) {
                    row.style.backgroundColor = 'rgba(129, 199, 132, 0.3)';
                }
            });
        }

        function updateVisualization() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const length = parseFloat(document.getElementById('length').value);
            const width = parseFloat(document.getElementById('width').value);
            const angle = parseFloat(document.getElementById('angle').value);
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            const margin = 80;
            const scaleX = (canvas.width - 2 * margin) / length;
            const scaleY = (canvas.height - 2 * margin) / width;
            const scale = Math.min(scaleX, scaleY);
            
            // è®¡ç®—åç§»é‡ä½¿å›¾å½¢å±…ä¸­
            const offsetX = (canvas.width - length * scale) / 2;
            const offsetY = (canvas.height - width * scale) / 2;
            
            // ç»˜åˆ¶åæ ‡è½´
            drawAxes(ctx, offsetX, offsetY, length * scale, width * scale, scale);
            
            // ç»˜åˆ¶é•¿æ–¹å½¢
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(offsetX, offsetY, length * scale, width * scale);
            
            // ç»˜åˆ¶é•¿æ–¹å½¢æ ‡æ³¨
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`é•¿: ${length}`, offsetX + length * scale / 2, offsetY - 10);
            ctx.save();
            ctx.translate(offsetX - 20, offsetY + width * scale / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(`å®½: ${width}`, 0, 0);
            ctx.restore();
            
            // ç»˜åˆ¶å½“å‰æ‰‹åŠ¨è°ƒæ•´çš„åŠåœ†
            const manualResult = findMaxRadiusForAngle(angle, length, width);
            if (manualResult.radius > 0) {
                drawSemicircle(ctx, manualResult.center.x * scale + offsetX, 
                              manualResult.center.y * scale + offsetY, 
                              manualResult.radius * scale, angle, '#ff4444', 'æ‰‹åŠ¨è°ƒæ•´');
            }
            
            // ç»˜åˆ¶æœ€ä¼˜è§£åŠåœ†
            if (currentOptimal.radius > 0) {
                drawSemicircle(ctx, currentOptimal.centerX * scale + offsetX, 
                              currentOptimal.centerY * scale + offsetY, 
                              currentOptimal.radius * scale, currentOptimal.angle, '#44ff44', 'æœ€ä¼˜è§£');
            }
            
            // ç»˜åˆ¶ç½‘æ ¼
            drawGrid(ctx, offsetX, offsetY, length * scale, width * scale, scale);
        }

        function drawAxes(ctx, offsetX, offsetY, rectWidth, rectHeight, scale) {
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.font = '12px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            
            // Xè½´
            ctx.beginPath();
            ctx.moveTo(offsetX - 20, offsetY + rectHeight + 20);
            ctx.lineTo(offsetX + rectWidth + 20, offsetY + rectHeight + 20);
            ctx.stroke();
            
            // Xè½´ç®­å¤´
            ctx.beginPath();
            ctx.moveTo(offsetX + rectWidth + 20, offsetY + rectHeight + 20);
            ctx.lineTo(offsetX + rectWidth + 15, offsetY + rectHeight + 15);
            ctx.moveTo(offsetX + rectWidth + 20, offsetY + rectHeight + 20);
            ctx.lineTo(offsetX + rectWidth + 15, offsetY + rectHeight + 25);
            ctx.stroke();
            
            // Xè½´æ ‡ç­¾
            ctx.fillText('X', offsetX + rectWidth + 30, offsetY + rectHeight + 25);
            
            // Yè½´
            ctx.beginPath();
            ctx.moveTo(offsetX - 20, offsetY + rectHeight + 20);
            ctx.lineTo(offsetX - 20, offsetY - 20);
            ctx.stroke();
            
            // Yè½´ç®­å¤´
            ctx.beginPath();
            ctx.moveTo(offsetX - 20, offsetY - 20);
            ctx.lineTo(offsetX - 25, offsetY - 15);
            ctx.moveTo(offsetX - 20, offsetY - 20);
            ctx.lineTo(offsetX - 15, offsetY - 15);
            ctx.stroke();
            
            // Yè½´æ ‡ç­¾
            ctx.fillText('Y', offsetX - 30, offsetY - 10);
            
            // åˆ»åº¦æ ‡è®°
            const length = parseFloat(document.getElementById('length').value);
            const width = parseFloat(document.getElementById('width').value);
            
            // Xè½´åˆ»åº¦
            for (let i = 0; i <= length; i += Math.max(1, Math.floor(length / 10))) {
                const x = offsetX + i * scale;
                ctx.beginPath();
                ctx.moveTo(x, offsetY + rectHeight + 15);
                ctx.lineTo(x, offsetY + rectHeight + 25);
                ctx.stroke();
                ctx.fillText(i.toString(), x, offsetY + rectHeight + 40);
            }
            
            // Yè½´åˆ»åº¦
            for (let i = 0; i <= width; i += Math.max(1, Math.floor(width / 10))) {
                const y = offsetY + rectHeight - i * scale;
                ctx.beginPath();
                ctx.moveTo(offsetX - 25, y);
                ctx.lineTo(offsetX - 15, y);
                ctx.stroke();
                ctx.textAlign = 'right';
                ctx.fillText(i.toString(), offsetX - 30, y + 4);
            }
        }

        function drawGrid(ctx, offsetX, offsetY, rectWidth, rectHeight, scale) {
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 0.5;
            
            const length = parseFloat(document.getElementById('length').value);
            const width = parseFloat(document.getElementById('width').value);
            
            // å‚ç›´ç½‘æ ¼çº¿
            for (let i = 0; i <= length; i++) {
                const x = offsetX + i * scale;
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + rectHeight);
                ctx.stroke();
            }
            
            // æ°´å¹³ç½‘æ ¼çº¿
            for (let i = 0; i <= width; i++) {
                const y = offsetY + rectHeight - i * scale;
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + rectWidth, y);
                ctx.stroke();
            }
        }

        function drawSemicircle(ctx, centerX, centerY, radius, angle, color, label) {
            const angleRad = angle * Math.PI / 180;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(angleRad);
            
            // ç»˜åˆ¶åŠåœ†å¼§
            ctx.strokeStyle = color;
            ctx.fillStyle = color + '40'; // åŠé€æ˜å¡«å……
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // ç»˜åˆ¶ç›´å¾„
            ctx.beginPath();
            ctx.moveTo(-radius, 0);
            ctx.lineTo(radius, 0);
            ctx.stroke();
            
            // ç»˜åˆ¶ä¸­å¿ƒç‚¹
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
            
            // ç»˜åˆ¶æ ‡ç­¾
            ctx.fillStyle = color;
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(label + ` (r=${(radius / parseFloat(document.getElementById('length').value) * 8).toFixed(2)})`, 
                        centerX + radius + 5, centerY - 5);
        }

        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('length').addEventListener('input', updateVisualization);
        document.getElementById('width').addEventListener('input', updateVisualization);
        document.getElementById('angle').addEventListener('input', function() {
            document.getElementById('angle-slider').value = this.value;
            updateVisualization();
        });
        document.getElementById('angle-slider').addEventListener('input', function() {
            document.getElementById('angle').value = this.value;
            updateVisualization();
        });

        function resetToDefault() {
            document.getElementById('length').value = 8;
            document.getElementById('width').value = 6;
            document.getElementById('angle').value = 0;
            document.getElementById('angle-slider').value = 0;
            document.getElementById('precision').value = 1;
            document.getElementById('center-step').value = 0.1;
            document.getElementById('radius-precision').value = 0.001;
            updateVisualization();
        }

        function animateOptimization() {
            // åŠ¨ç”»æ¼”ç¤ºåŠŸèƒ½
            isAnimating = true;
            const animateBtn = document.getElementById('animate-btn');
            animateBtn.disabled = true;
            
            let currentAngle = 0;
            const step = 5;
            
            function animate() {
                if (!isAnimating || currentAngle > 180) {
                    animateBtn.disabled = false;
                    isAnimating = false;
                    return;
                }
                
                document.getElementById('angle').value = currentAngle;
                document.getElementById('angle-slider').value = currentAngle;
                updateVisualization();
                
                currentAngle += step;
                setTimeout(animate, 200);
            }
            
            animate();
        }

        function stopAnimation() {
            isAnimating = false;
            document.getElementById('animate-btn').disabled = false;
            document.getElementById('optimize-btn').disabled = false;
        }

        function generateReport() {
            const report = {
                rectangle: {
                    length: parseFloat(document.getElementById('length').value),
                    width: parseFloat(document.getElementById('width').value)
                },
                optimal: currentOptimal,
                perimeter: currentOptimal.radius * (Math.PI + 2),
                area: currentOptimal.radius * currentOptimal.radius * Math.PI / 2,
                calculationHistory: calculationHistory
            };
            
            console.log('è®¡ç®—æŠ¥å‘Š:', report);
            alert('æŠ¥å‘Šå·²ç”Ÿæˆï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°');
        }

        function exportData() {
            const data = {
                timestamp: new Date().toISOString(),
                rectangle: {
                    length: parseFloat(document.getElementById('length').value),
                    width: parseFloat(document.getElementById('width').value)
                },
                optimal: currentOptimal,
                results: calculationHistory
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'semicircle_optimization_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportToCSV() {
            if (calculationHistory.length === 0) {
                alert('è¯·å…ˆè¿è¡Œä¼˜åŒ–è®¡ç®—');
                return;
            }
            
            let csv = 'Angle,Radius,Perimeter,Area,CenterX,CenterY\n';
            calculationHistory.forEach(result => {
                csv += `${result.angle},${result.radius},${result.perimeter},${result.area},${result.centerX},${result.centerY}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'semicircle_results.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportToJSON() {
            exportData();
        }

        function exportImage() {
            const canvas = document.getElementById('canvas');
            const link = document.createElement('a');
            link.download = 'semicircle_visualization.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function printResults() {
            window.print();
        }

        // ç”»å¸ƒç‚¹å‡»äº‹ä»¶
        document.getElementById('canvas').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const length = parseFloat(document.getElementById('length').value);
            const width = parseFloat(document.getElementById('width').value);
            const margin = 80;
            const scaleX = (this.width - 2 * margin) / length;
            const scaleY = (this.height - 2 * margin) / width;
            const scale = Math.min(scaleX, scaleY);
            const offsetX = (this.width - length * scale) / 2;
            const offsetY = (this.height - width * scale) / 2;
            
            const realX = (x - offsetX) / scale;
            const realY = (this.height - y - (this.height - offsetY - width * scale)) / scale;
            
            document.getElementById('canvas-info').innerHTML = `
                <div><strong>å›¾ä¾‹:</strong></div>
                <div>ğŸŸ¢ æœ€ä¼˜è§£</div>
                <div>ğŸ”´ å½“å‰æ‰‹åŠ¨</div>
                <div>ğŸ“ å°ºå¯¸æ ‡æ³¨</div>
                <div>ğŸ¯ ç‚¹å‡»åæ ‡: (${realX.toFixed(2)}, ${realY.toFixed(2)})</div>
            `;
        });

        // åˆå§‹åŒ–
        updateVisualization();
    </script>
</body>
</html>